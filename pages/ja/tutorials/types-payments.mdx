# NERO Chainトランザクションの支払い方法

このチュートリアルでは、NERO Chain Paymasterを使用してトランザクションのガス料金に異なる支払い方法を実装する方法を説明します。スポンサー付きトランザクションの代替としてERC20トークン支払いに焦点を当てています。

## 学習内容
- NERO Chain Paymasterがサポートするトークンのリストを取得する方法
- トランザクションに異なる支払いタイプ（スポンサー付き、前払い、後払い）を実装する方法
- Paymasterの操作のためのトークン承認を処理する方法
- アプリケーションの支払い選択インターフェースを構築する方法

## 前提条件
- [AAウォレット統合](/ja/tutorials/aa-wallet-integration)チュートリアルを完了していること
- [UserOperationsの送信](/ja/tutorials/sending-ops)チュートリアル（スポンサー付きトランザクション）を完了していること
- [NERO Chain AAプラットフォーム](https://aa-platform.nerochain.io)からのAPIキー

## Paymaster支払いタイプの理解

前回のチュートリアルでは、開発者がすべてのガスコストを負担するスポンサー付きトランザクション（タイプ0）の使用方法を学びました。NERO Chain Paymasterは、さらに2つの支払いタイプをサポートしています：

1. **ERC20前払い（タイプ1）**：ユーザーはERC20トークンでガスコストを前払いします
2. **ERC20後払い（タイプ2）**：ユーザーはトランザクション実行後にERC20トークンでガスコストを支払います

これらの支払いタイプを実装する前に、まずPaymaster APIからサポートされているトークンを取得する必要があります。

## ステップ1：サポートされているトークンの取得

サポートされているトークンを照会するユーティリティ関数を作成しましょう：

```typescript
// src/utils/aaUtils.ts
import { ethers } from 'ethers';
import { Client, Presets } from 'userop';
import { 
  NERO_CHAIN_CONFIG, 
  AA_PLATFORM_CONFIG, 
  CONTRACT_ADDRESSES,
  API_KEY 
} from '../config';

// 過剰なAPI呼び出しを避けるためのキャッシュ
let tokenCache: any[] = [];
let lastFetchTime: number = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5分

// トークンレスポンスデータの変換
const transformTokensResponse = (response: any) => {
  if (!response || !response.tokens) return [];
  
  return response.tokens.map((token: any) => ({
    address: token.token,
    decimal: parseInt(token.decimal),
    symbol: token.symbol,
    type: parseInt(token.type),
    price: token.price ? parseFloat(token.price) : undefined
  }));
};

// Paymaster APIからサポートされているトークンを取得
export const getSupportedTokens = async (accountSigner: ethers.Signer) => {
  // まずキャッシュをチェック
  const now = Date.now();
  if (tokenCache.length > 0 && now - lastFetchTime < CACHE_DURATION) {
    console.log("キャッシュされたトークンリストを使用");
    return tokenCache;
  }
  
  try {
    // SimpleAccountビルダーを初期化
    const builder = await Presets.Builder.SimpleAccount.init(
      accountSigner,
      NERO_CHAIN_CONFIG.rpcUrl,
      {
        overrideBundlerRpc: AA_PLATFORM_CONFIG.bundlerRpc,
        entryPoint: CONTRACT_ADDRESSES.entryPoint,
        factory: CONTRACT_ADDRESSES.accountFactory,
      }
    );
    
    // AAウォレットアドレスを取得
    const sender = await builder.getSender();
    
    // トークンを照会するための最小限のUserOp
    const minimalUserOp = {
      sender,
      nonce: "0x0",
      initCode: "0x",
      callData: "0x",
      callGasLimit: "0x88b8",
      verificationGasLimit: "0x33450",
      preVerificationGas: "0xc350",
      maxFeePerGas: "0x2162553062",
      maxPriorityFeePerGas: "0x40dbcf36",
      paymasterAndData: "0x",
      signature: "0x"
    };
    
    // paymaster API呼び出し用のプロバイダーを設定
    const provider = new ethers.providers.JsonRpcProvider(AA_PLATFORM_CONFIG.paymasterRpc);
    
    // paymaster APIからサポートされているトークンを照会
    const tokensResponse = await provider.send("pm_supported_tokens", [
      minimalUserOp,
      API_KEY,
      CONTRACT_ADDRESSES.entryPoint
    ]);
    
    // 結果を変換してキャッシュ
    const tokens = transformTokensResponse(tokensResponse);
    tokenCache = tokens;
    lastFetchTime = now;
    
    console.log(`${tokens.length}個のサポートされているトークンが見つかりました`);
    return tokens;
  } catch (error) {
    console.error("サポートされているトークンの取得エラー:", error);
    
    // 利用可能な場合はキャッシュデータを返し、それ以外は空の配列
    return tokenCache.length > 0 ? tokenCache : [];
  }
};
```

## ステップ2：ERC20トークン承認の処理

ERC20トークンをガスに使用する場合（支払いタイプ1と2）、ユーザーのAAウォレットは最初にトークンペイマスターコントラクトを承認する必要があります：

```typescript
// src/utils/aaUtils.ts
// 既存のユーティリティ関数に以下を追加

// ペイマスターのトークン承認を処理
export const approveTokenForPaymaster = async (
  accountSigner: ethers.Signer,
  tokenAddress: string,
  amount: string = ethers.constants.MaxUint256.toString()
) => {
  try {
    // クライアントを初期化
    const client = await Client.init(NERO_CHAIN_CONFIG.rpcUrl, {
      overrideBundlerRpc: AA_PLATFORM_CONFIG.bundlerRpc,
      entryPoint: CONTRACT_ADDRESSES.entryPoint,
    });
    
    // ビルダーを初期化
    const builder = await Presets.Builder.SimpleAccount.init(
      accountSigner,
      NERO_CHAIN_CONFIG.rpcUrl,
      {
        overrideBundlerRpc: AA_PLATFORM_CONFIG.bundlerRpc,
        entryPoint: CONTRACT_ADDRESSES.entryPoint,
        factory: CONTRACT_ADDRESSES.accountFactory,
      }
    );
    
    // AAウォレットアドレスを取得
    const aaWalletAddress = await builder.getSender();
    
    // トークンコントラクトインターフェースを作成
    const erc20Interface = new ethers.utils.Interface([
      'function approve(address spender, uint256 amount) returns (bool)',
      'function allowance(address owner, address spender) view returns (uint256)'
    ]);
    
    // 現在の許可額を確認
    const provider = new ethers.providers.JsonRpcProvider(NERO_CHAIN_CONFIG.rpcUrl);
    const tokenContract = new ethers.Contract(
      tokenAddress,
      [
        'function allowance(address owner, address spender) view returns (uint256)'
      ],
      provider
    );
    
    const currentAllowance = await tokenContract.allowance(
      aaWalletAddress,
      CONTRACT_ADDRESSES.tokenPaymaster
    );
    
    // 許可額が十分な場合は早期に戻る
    if (!currentAllowance.lt(ethers.utils.parseUnits("100", 18))) {
      console.log("トークンは既に承認されています");
      return true;
    }
    
    console.log("ペイマスターのトークンを承認中...");
    
    // 承認のコールデータを作成
    const approveCallData = erc20Interface.encodeFunctionData(
      'approve',
      [CONTRACT_ADDRESSES.tokenPaymaster, amount]
    );
    
    // 無料ガス用のペイマスターを設定（承認トランザクション用）
    builder.setPaymasterOptions({
      apikey: API_KEY,
      rpc: AA_PLATFORM_CONFIG.paymasterRpc,
      type: "0" // 承認には無料を使用
    });
    
    // ガスパラメータを設定
    const gasParams = {
      callGasLimit: "0x88b8",
      verificationGasLimit: "0x33450",
      preVerificationGas: "0xc350",
      maxFeePerGas: "0x2162553062",
      maxPriorityFeePerGas: "0x40dbcf36",
    };
    
    builder.setCallGasLimit(gasParams.callGasLimit);
    builder.setVerificationGasLimit(gasParams.verificationGasLimit);
    builder.setPreVerificationGas(gasParams.preVerificationGas);
    builder.setMaxFeePerGas(gasParams.maxFeePerGas);
    builder.setMaxPriorityFeePerGas(gasParams.maxPriorityFeePerGas);
    
    // 承認用のUserOperationを作成
    const userOp = await builder.execute(tokenAddress, 0, approveCallData);
    
    // 承認UserOperationを送信
    console.log("承認トランザクションを送信中...");
    const res = await client.sendUserOperation(userOp);
    console.log("承認トランザクションが送信されました。ハッシュ:", res.userOpHash);
    
    // 承認がマイニングされるのを待つ
    const receipt = await res.wait();
    if (!receipt) {
            throw new Error("トランザクションレシートがnullです");
    }
    console.log("トークン承認がブロックで確認されました:", receipt.blockNumber);
    
    return true;
  } catch (error) {
    console.error("ペイマスターのトークン承認エラー:", error);
    throw error;
  }
};
```

## ステップ3：統一されたトランザクション関数の実装

各支払いタイプに対して別々の関数を作成する代わりに、すべてのタイプを処理できる単一の関数を作成しましょう：

```typescript
// src/utils/aaUtils.ts
/**
 * 設定可能な支払いタイプで操作を実行
 * @param accountSigner ユーザーの署名者
 * @param contractAddress ターゲットコントラクトアドレス
 * @param contractAbi コントラクトABI
 * @param functionName 呼び出す関数
 * @param functionParams 関数のパラメータ
 * @param paymentType 支払いタイプ（0:スポンサー付き、1:前払い、2:後払い）
 * @param tokenAddress ERC20トークンアドレス（タイプ1と2に必要）
 */
export const executeOperation = async (
  accountSigner: ethers.Signer,
  contractAddress: string,
  contractAbi: string[] | string,
  functionName: string,
  functionParams: any[],
  paymentType: number = 0,
  tokenAddress?: string
) => {
  try {
    // クライアントを初期化
    const client = await Client.init(NERO_CHAIN_CONFIG.rpcUrl, {
      overrideBundlerRpc: AA_PLATFORM_CONFIG.bundlerRpc,
      entryPoint: CONTRACT_ADDRESSES.entryPoint,
    });
    
    // ビルダーを初期化
    const builder = await Presets.Builder.SimpleAccount.init(
      accountSigner,
      NERO_CHAIN_CONFIG.rpcUrl,
      {
        overrideBundlerRpc: AA_PLATFORM_CONFIG.bundlerRpc,
        entryPoint: CONTRACT_ADDRESSES.entryPoint,
        factory: CONTRACT_ADDRESSES.accountFactory,
      }
    );
    
    // コントラクトインターフェースを作成
    const contractInterface = new ethers.utils.Interface(contractAbi);
    
    // 関数呼び出しのコールデータをエンコード
    const callData = contractInterface.encodeFunctionData(
      functionName,
      functionParams
    );
    
    // トークン支払いタイプの場合、トークン承認を確認
    if (paymentType > 0) {
      if (!tokenAddress) {
        throw new Error("トークンアドレスが支払いタイプに必要です " + paymentType);
      }
      
      // トークン承認を確認
      await approveTokenForPaymaster(accountSigner, tokenAddress);
    }
    
    // 支払いタイプに基づいてペイマスターオプションを設定
    if (paymentType === 0) {
      // タイプ0：スポンサー付き（開発者がガスを負担）
      builder.setPaymasterOptions({
        apikey: API_KEY,
        rpc: AA_PLATFORM_CONFIG.paymasterRpc,
        type: "0"
      });
    } else if (paymentType === 1) {
      // タイプ1：ERC20トークンによる前払い
      builder.setPaymasterOptions({
        apikey: API_KEY,
        rpc: AA_PLATFORM_CONFIG.paymasterRpc,
        type: "1",
        token: tokenAddress
      });
    } else if (paymentType === 2) {
      // タイプ2：ERC20トークンによる後払い
      builder.setPaymasterOptions({
        apikey: API_KEY,
        rpc: AA_PLATFORM_CONFIG.paymasterRpc,
        type: "2",
        token: tokenAddress
      });
    } else {
      throw new Error("サポートされていない支払いタイプ: " + paymentType);
    }
    
    // ガスパラメータを設定
    // 実際のアプリではガス見積もりを使用するべき
    const gasParams = {
      callGasLimit: "0x88b8",
      verificationGasLimit: "0x33450",
      preVerificationGas: "0xc350",
      maxFeePerGas: "0x2162553062",
      maxPriorityFeePerGas: "0x40dbcf36",
    };
    
    builder.setCallGasLimit(gasParams.callGasLimit);
    builder.setVerificationGasLimit(gasParams.verificationGasLimit);
    builder.setPreVerificationGas(gasParams.preVerificationGas);
    builder.setMaxFeePerGas(gasParams.maxFeePerGas);
    builder.setMaxPriorityFeePerGas(gasParams.maxPriorityFeePerGas);
    
    // 操作の実行
    console.log(`コントラクト ${contractAddress} の ${functionName} を呼び出し中...`);
    const userOp = await builder.execute(contractAddress, 0, callData);
    
    // UserOperationを送信
    console.log("UserOperationを送信中...");
    const res = await client.sendUserOperation(userOp);
    console.log("UserOperation送信されました。ハッシュ:", res.userOpHash);
    
    // トランザクションがマイニングされるのを待つ
    const receipt = await res.wait();
    if (!receipt) {
      throw new Error("トランザクションレシートがnullです");
    }
    
    console.log("トランザクションが確認されました:", receipt.transactionHash);
    return receipt;
  } catch (error) {
    console.error("操作実行エラー:", error);
    throw error;
  }
};
```

## ステップ4：支払い選択コンポーネントの作成

ユーザーがトランザクションの支払い方法を選択できるコンポーネントを作成しましょう：

```typescript
// src/components/PaymentTypeSelector.tsx
import React, { useState, useEffect } from 'react';
import { getSupportedTokens, executeOperation } from '../utils/aaUtils';
import { ethers } from 'ethers';

interface PaymentTypeSelectorProps {
  accountSigner: ethers.Signer;
  contractAddress: string;
  contractAbi: string[];
  functionName: string;
  functionParams: any[];
  onSuccess?: (receipt: any) => void;
  onError?: (error: any) => void;
}

const PaymentTypeSelector: React.FC<PaymentTypeSelectorProps> = ({
  accountSigner,
  contractAddress,
  contractAbi,
  functionName,
  functionParams,
  onSuccess,
  onError
}) => {
  const [paymentType, setPaymentType] = useState<number>(0);
  const [tokens, setTokens] = useState<any[]>([]);
  const [selectedToken, setSelectedToken] = useState<string>('');
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  
  // コンポーネントマウント時にトークンをロード
  useEffect(() => {
    const loadTokens = async () => {
      try {
        setIsLoading(true);
        const supportedTokens = await getSupportedTokens(accountSigner);
        setTokens(supportedTokens);
      } catch (error) {
        console.error("トークン取得エラー:", error);
      } finally {
        setIsLoading(false);
      }
    };
    
    loadTokens();
  }, [accountSigner]);
  
  // 支払いタイプ変更ハンドラー
  const handlePaymentTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const type = parseInt(e.target.value);
    setPaymentType(type);
    setSelectedToken(''); // タイプが変わったらトークン選択をリセット
  };
  
  // トークン選択ハンドラー
  const handleTokenChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedToken(e.target.value);
  };
  
  // 送信ハンドラー
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // 支払いタイプとトークンの検証
    if (paymentType > 0 && !selectedToken) {
      alert("トークンを選択してください");
      return;
    }
    
    try {
      setIsSubmitting(true);
      
      // トランザクションを実行
      const receipt = await executeOperation(
        accountSigner,
        contractAddress,
        contractAbi,
        functionName,
        functionParams,
        paymentType,
        selectedToken
      );
      
      // 成功コールバックを呼び出し
      if (onSuccess) {
        onSuccess(receipt);
      }
      
    } catch (error) {
      console.error("トランザクション失敗:", error);
      
      // エラーコールバックを呼び出し
      if (onError) {
        onError(error);
      }
    } finally {
      setIsSubmitting(false);
    }
  };
  
  // ユーザーがトランザクションを送信できるかどうかを判断
  const canSubmit = paymentType === 0 || (paymentType > 0 && selectedToken);
  
  return (
    <div className="payment-type-selector">
      <h3>トランザクションの支払い方法を選択</h3>
      
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label htmlFor="payment-type">支払いタイプ：</label>
          <select
            id="payment-type"
            value={paymentType}
            onChange={handlePaymentTypeChange}
            disabled={isSubmitting}
          >
            <option value={0}>スポンサー付き (開発者が支払い)</option>
            <option value={1}>ERC20トークンで前払い</option>
            <option value={2}>ERC20トークンで後払い</option>
          </select>
        </div>
        
        {paymentType > 0 && (
          <div className="form-group">
            <label htmlFor="token-select">トークン：</label>
            {isLoading ? (
              <p>トークンを読み込み中...</p>
            ) : (
              <select
                id="token-select"
                value={selectedToken}
                onChange={handleTokenChange}
                disabled={isSubmitting}
              >
                <option value="">トークンを選択してください</option>
                {tokens.map((token) => (
                  <option key={token.address} value={token.address}>
                    {token.symbol || "不明"}
                  </option>
                ))}
              </select>
            )}
          </div>
        )}
        
        <button 
          type="submit" 
          disabled={isSubmitting || !canSubmit}
          className="submit-button"
        >
          {isSubmitting ? "送信中..." : "トランザクションを送信"}
        </button>
      </form>
    </div>
  );
};

export default PaymentTypeSelector;
```

## ステップ5：コンポーネントの使用

支払い選択コンポーネントを親コンポーネントで使用する方法をお見せします：

```typescript
// src/components/ExampleUsage.tsx
import React, { useState } from 'react';
import { ethers } from 'ethers';
import { getSigner } from '../utils/aaUtils';
import PaymentTypeSelector from './PaymentTypeSelector';

const ExampleUsage: React.FC = () => {
  const [txHash, setTxHash] = useState<string>('');
  const [error, setError] = useState<string>('');
  
  // 例としてのERC721コントラクト
  const nftContractAddress = "0x1234567890123456789012345678901234567890"; // 実際のアドレスに置き換え
  const nftAbi = [
    "function mint(address to) external returns (uint256)"
  ];
  
  // トランザクション成功ハンドラー
  const handleSuccess = (receipt: any) => {
    setTxHash(receipt.transactionHash);
    setError('');
  };
  
  // トランザクションエラーハンドラー
  const handleError = (err: any) => {
    setError(err.message || "不明なエラー");
    setTxHash('');
  };
  
  return (
    <div className="example-usage">
      <h2>NFTをミント</h2>
      
      {/* PaymentTypeSelectorを使用 */}
      <PaymentTypeSelector
        accountSigner={/* 署名者 */}
        contractAddress={nftContractAddress}
        contractAbi={nftAbi}
        functionName="mint"
        functionParams={[/* ユーザーのアドレス */]}
        onSuccess={handleSuccess}
        onError={handleError}
      />
      
      {txHash && (
        <div className="success">
          <p>ミント成功！</p>
          <a
            href={`https://testnet.neroscan.io/tx/${txHash}`}
            target="_blank"
            rel="noopener noreferrer"
          >
            エクスプローラーで表示
          </a>
        </div>
      )}
      
      {error && (
        <div className="error">
          <p>エラー: {error}</p>
        </div>
      )}
    </div>
  );
};

export default ExampleUsage;
```

## まとめ

お疲れ様でした！このチュートリアルでは以下を実装しました：

1. NERO Chain Paymasterがサポートするトークンを取得する関数
2. 異なる支払いタイプでトランザクションを実行する統一された関数
3. ERC20トークン承認処理のロジック
4. ユーザーが支払い方法を選択できるUIコンポーネント

これらの実装により、アプリケーションはより多くの支払いオプションを提供でき、ユーザーがNEROトークンを持っていない場合でもトランザクションを実行できるようになりました。

次のチュートリアルでは、これらの概念を組み合わせてより洗練された[支払いトークン選択UI](/ja/tutorials/checking-sup-tokens)を構築します。
