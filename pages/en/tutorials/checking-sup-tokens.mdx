# How to Check Supported Tokens for the NERO Chain's Paymaster

This tutorial explains how to query and display the tokens that are supported by the NERO Chain Paymaster for gas fee payments.

## Understanding Supported Tokens

The NERO Chain's Paymaster allows users to pay gas fees using various ERC20 tokens. However, not all tokens are supported, and the list may vary depending on:

1. The API key configuration
2. The chain you're operating on
3. The paymaster's current settings

## Pre-requisites

You can either create a new react project with typescript or use our simple template repository to follow along. If you create a new project, be sure to install the below dependencies:

```bash
npm install github:nerochain/aa-userop-sdk
```

and 

```bash
npm install ethers@5.7.2
```

If you want to follow this using our template, use the below:

```
git clone https://github.com/souzavinny/application-templates-nero.git my-application
cd my-application
cd react-ts
npm install
```
> **_NOTE_**: More components will be available in the template folder.

## Step 1: Creating a Function to Get Supported Tokens

First, let's create a utility function to query the supported tokens:

```typescript
// src/utils/aaUtils.ts
import { ethers } from 'ethers';
import { Client, Presets } from 'userop';
import { 
  NERO_CHAIN_CONFIG, 
  AA_PLATFORM_CONFIG, 
  CONTRACT_ADDRESSES,
  API_KEY 
} from '../config';

// Cache to avoid excessive API calls
let tokenCache: any[] = [];
let lastFetchTime: number = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Transform token response data
const transformTokensResponse = (response: any) => {
  if (!response || !response.tokens) return [];
  
  return response.tokens.map((token: any) => ({
    address: token.token,
    decimal: parseInt(token.decimal),
    symbol: token.symbol,
    type: parseInt(token.type),
    price: token.price ? parseFloat(token.price) : undefined
  }));
};

// Get supported tokens from Paymaster API
export const getSupportedTokens = async (client: any, builder: any) => {
  // Check cache first
  const now = Date.now();
  if (tokenCache.length > 0 && now - lastFetchTime < CACHE_DURATION) {
    console.log("Using cached token list");
    return tokenCache;
  }
  
  try {
    // Get the AA wallet address
    const sender = await builder.getSender();
    
    // Create a minimal UserOp for querying tokens
    const minimalUserOp = {
      sender,
      nonce: "0x0",
      initCode: "0x",
      callData: "0x",
      callGasLimit: "0x88b8",
      verificationGasLimit: "0x33450",
      preVerificationGas: "0xc350",
      maxFeePerGas: "0x2162553062",
      maxPriorityFeePerGas: "0x40dbcf36",
      paymasterAndData: "0x",
      signature: "0x"
    };
    
    // Setup provider for paymaster API call
    const provider = new ethers.providers.JsonRpcProvider(AA_PLATFORM_CONFIG.paymasterRpc);
    
    // Query supported tokens from paymaster API
    const tokensResponse = await provider.send("pm_supported_tokens", [
      minimalUserOp,
      API_KEY,
      CONTRACT_ADDRESSES.entryPoint
    ]);
    
    // Transform and cache the results
    const tokens = transformTokensResponse(tokensResponse);
    tokenCache = tokens;
    lastFetchTime = now;
    
    console.log(`Found ${tokens.length} supported tokens`);
    return tokens;
  } catch (error) {
    console.error("Error fetching supported tokens:", error);
    
    // Return cached data if available, otherwise empty array
    return tokenCache.length > 0 ? tokenCache : [];
  }
};
```

## Step 2: Creating a Component to Display Tokens

Now, let's create a React component to display the supported tokens:

```typescript
// src/components/SupportedTokens.tsx
import React, { useState, useEffect } from 'react';
import { getSigner, initAAClient, initAABuilder, getSupportedTokens } from '../utils/aaUtils';

interface Token {
  address: string;
  symbol: string;
  decimal: number;
  type: number;
  price?: number;
}

const SupportedTokens: React.FC = () => {
  const [tokens, setTokens] = useState<Token[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadTokens = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // Get signer from connected wallet
      const signer = await getSigner();
      
      // Initialize the AA client and builder
      const client = await initAAClient(signer);
      const builder = await initAABuilder(signer);
      
      // Fetch supported tokens
      const supportedTokens = await getSupportedTokens(client, builder);
      setTokens(supportedTokens);
    } catch (error: any) {
      console.error("Error loading tokens:", error);
      setError(error.message || "Failed to load supported tokens");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    // Load tokens when component mounts
    loadTokens();
  }, []);

  return (
    <div className="supported-tokens">
      <h2>Supported Tokens for Gas Payment</h2>
      
      <div className="token-actions">
        <button 
          onClick={loadTokens} 
          disabled={isLoading}
        >
          {isLoading ? "Loading..." : "Refresh Token List"}
        </button>
      </div>
      
      {error && (
        <div className="error-message">
          Error: {error}
        </div>
      )}
      
      {isLoading ? (
        <div className="loading">Loading supported tokens...</div>
      ) : tokens.length > 0 ? (
        <div className="token-list">
          <table>
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Address</th>
                <th>Decimals</th>
                <th>Payment Type</th>
                {tokens.some(t => t.price !== undefined) && <th>Price</th>}
              </tr>
            </thead>
            <tbody>
              {tokens.map((token) => (
                <tr key={token.address}>
                  <td>{token.symbol}</td>
                  <td>
                    <span className="address">
                      {token.address.substring(0, 6)}...{token.address.substring(token.address.length - 4)}
                    </span>
                  </td>
                  <td>{token.decimal}</td>
                  <td>{token.type === 1 ? "Prepay" : token.type === 2 ? "Postpay" : "Unknown"}</td>
                  {tokens.some(t => t.price !== undefined) && (
                    <td>{token.price ? `$${token.price.toFixed(4)}` : "-"}</td>
                  )}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <p>No supported tokens found. Make sure your API key is configured correctly.</p>
      )}
    </div>
  );
};

export default SupportedTokens;
```

## Step 3: Getting Token Balances

To provide a better user experience, you should also check the user's balance for each supported token:

```typescript
// Add to src/utils/aaUtils.ts
// Get balance for a specific token
export const getTokenBalance = async (address: string, tokenAddress: string) => {
  try {
    // Create provider
    const provider = new ethers.providers.JsonRpcProvider(NERO_CHAIN_CONFIG.rpcUrl);
    
    // Create contract instance
    const erc20Contract = new ethers.Contract(
      tokenAddress,
      [
        'function balanceOf(address) view returns (uint256)',
        'function decimals() view returns (uint8)'
      ],
      provider
    );
    
    // Get balance and decimals
    const balance = await erc20Contract.balanceOf(address);
    let decimals = 18; // Default
    
    try {
      decimals = await erc20Contract.decimals();
    } catch (err) {
      console.warn(`Couldn't get decimals for token ${tokenAddress}, using default 18`);
    }
    
    // Format balance for display
    const formattedBalance = ethers.utils.formatUnits(balance, decimals);
    return formattedBalance;
  } catch (error) {
    console.error(`Error getting token balance for ${tokenAddress}:`, error);
    return "0";
  }
};

// Get balances for multiple tokens
export const getAllTokenBalances = async (userAddress: string, tokens: any[]) => {
  const balances: {[key: string]: string} = {};
  
  // Get balance for each token
  await Promise.all(
    tokens.map(async (token) => {
      const balance = await getTokenBalance(userAddress, token.address);
      balances[token.address] = balance;
    })
  );
  
  return balances;
};
```

## Step 4: Enhancing the Component with Balances

Now, let's enhance our component to show token balances:

```typescript
// Update src/components/SupportedTokens.tsx
// Add state for balances
const [balances, setBalances] = useState<{[key: string]: string}>({});
const [loadingBalances, setLoadingBalances] = useState(false);

// Add function to load balances
const loadBalances = async () => {
  if (!tokens.length) return;
  
  try {
    setLoadingBalances(true);
    
    // Get signer from connected wallet
    const signer = await getSigner();
    const address = await signer.getAddress();
    
    // Get AA wallet address
    const aaWalletAddress = await getAAWalletAddress(signer);
    
    // Fetch balances for all tokens
    const tokenBalances = await getAllTokenBalances(aaWalletAddress, tokens);
    setBalances(tokenBalances);
  } catch (error) {
    console.error("Error loading token balances:", error);
  } finally {
    setLoadingBalances(false);
  }
};

// Call loadBalances when tokens are loaded
useEffect(() => {
  if (tokens.length > 0) {
    loadBalances();
  }
}, [tokens]);

// Update table rendering to include balances
<tr key={token.address}>
  <td>{token.symbol}</td>
  <td>
    <span className="address">
      {token.address.substring(0, 6)}...{token.address.substring(token.address.length - 4)}
    </span>
  </td>
  <td>{token.decimal}</td>
  <td>{token.type === 1 ? "Prepay" : token.type === 2 ? "Postpay" : "Unknown"}</td>
  <td className="balance">
    {loadingBalances 
      ? "Loading..." 
      : `${parseFloat(balances[token.address] || "0").toLocaleString(undefined, {
          minimumFractionDigits: 0,
          maximumFractionDigits: 4
        })}`
    }
  </td>
  {tokens.some(t => t.price !== undefined) && (
    <td>{token.price ? `$${token.price.toFixed(4)}` : "-"}</td>
  )}
</tr>
```

## Understanding the Response Data

The supported tokens response includes these key fields:

- **address**: The ERC20 token contract address
- **symbol**: The token symbol (e.g., "DAI", "USDT")
- **decimal**: The number of decimals the token uses
- **type**: The payment type supported (1 for prepay, 2 for postpay)
- **price**: Optional price information in USD

## Tips for Production Use

1. **Caching**: Always cache the token list as shown to minimize API calls
2. **Error Handling**: Implement proper fallbacks if the token API is unavailable
3. **Rate Limiting**: Be aware of API rate limits and implement exponential backoff for retries
4. **Balance Checks**: Always check if the user has sufficient balance before trying to use a token
5. **UX Design**: Sort tokens by balance or payment type to help users choose the best option