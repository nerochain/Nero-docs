import PageFeedback from '../../../../components/PageFeedback'
# Configuring and Understanding NERO Wallet and Paymaster

This guide explains the design choices and implementation details behind our NERO Wallet dApp enhancements. It serves as both a tutorial and an explanation of account abstraction concepts.

## What is Account Abstraction?

Account abstraction (AA) enables smart contract wallets to act like regular user accounts but with advanced features. Unlike traditional EOA (Externally Owned Account) wallets that rely on private keys, AA wallets use smart contracts to process transactions, enabling features like:

- Multi-signature authentication
- Gas sponsorship (no need for users to hold gas tokens)
- Transaction batching
- Account recovery mechanisms
- Programmable security rules

## Understanding User Operations (UserOps)

In the NERO Wallet implementation, we use the ERC-4337 standard which introduces the concept of User Operations (UserOps). These differ from regular transactions:

1. **Regular Transaction**: Directly submitted to the blockchain, requiring gas fees paid by the sender.
2. **User Operation**: Submitted to a separate mempool and processed by special infrastructure called bundlers and paymasters.

### UserOp Structure Flow:

```
User → UserOp → Bundler → EntryPoint Contract → Smart Contract Wallet → Target Contract
```

### Key Components:

- **Bundler**: Collects UserOps and submits them to the blockchain
- **Paymaster**: Sponsors gas fees on behalf of users
- **EntryPoint Contract**: Central contract that validates and executes UserOps

## Why We Used UserOps for Write Operations but Direct RPC for Read Operations

### For Write Operations (Mint NFT, Create Token):

```javascript
await execute({
  function: 'mint',
  contractAddress: FREE_NFT_ADDRESS,
  abi: NERO_NFT_ABI,
  params: [AAaddress, nftImageUrl],
  value: 0,
});
```

**Benefits of UserOps for Writing**:

1. **Gas Abstraction**: Users don't need to hold native tokens to pay for gas
2. **Batching**: Multiple operations can be combined (though we didn't implement this)
3. **Signature Abstraction**: Users can authenticate with social logins instead of private keys
4. **Better UX**: Simplifies the interaction flow for users

### For Read Operations (NFT Gallery):

```javascript
const provider = new ethers.providers.JsonRpcProvider(config.rpcUrl);
const nftContract = new ethers.Contract(FREE_NFT_ADDRESS, NERO_NFT_ABI, provider);
const balance = await nftContract.balanceOf(AAaddress);
```

**Benefits of Direct RPC for Reading**:

1. **Efficiency**: No need to create UserOps for read-only operations
2. **Cost**: Read operations are free and don't require gas
3. **Speed**: Direct RPC calls are faster as they bypass the bundler/paymaster infrastructure
4. **Simplicity**: Easier to implement and debug

## The NERO Wallet Architecture

The NERO Wallet leverages several key components:

### 1. Web3Auth Integration

The wallet uses Web3Auth for social login capabilities, enabling users to log in with their Google/Facebook accounts instead of managing private keys.

```javascript
// From nerowallet.config.ts
web3auth: {
  clientId: import.meta.env.VITE_TESTNET_WEB3AUTH_ID ?? '',
  network: 'testnet',
  uiConfig: {
    appName: 'NERO',
    // ... other config
  },
  loginConfig: {
    google: {
      // ... google config
    },
    facebook: {
      // ... facebook config
    }
  }
}
```

### 2. Configuration Context

The wallet uses a configuration context to manage chain details, RPC URLs, and contract addresses. This allows the dApp to work across different networks (testnet/mainnet):

```javascript
const config = useConfig(); // Access RPC URL, chain info, etc.
```

### 3. Smart Contract Interaction

The wallet interacts with smart contracts in two ways:

**For Write Operations (via useSendUserOp hook)**:
```javascript
const { execute, waitForUserOpResult } = useSendUserOp();
await execute({/* operation details */});
const result = await waitForUserOpResult();
```

**For Read Operations (via ethers.js)**:
```javascript
const provider = new ethers.providers.JsonRpcProvider(config.rpcUrl);
const contract = new ethers.Contract(address, abi, provider);
const data = await contract.someReadFunction();
```

## Implementation Strategy Explained

### 1. NFT Minting Strategy

We implement NFT minting using UserOps because:

1. **It's a State-Changing Operation**: Minting creates a new token and updates state
2. **Gas Requirements**: Requires gas payment, which can be abstracted via a paymaster
3. **Better UX**: Users don't need ETH/NERO tokens to mint an NFT

```javascript
// Execute the mint operation via a UserOp
await execute({
  function: 'mint',
  contractAddress: FREE_NFT_ADDRESS,
  abi: NERO_NFT_ABI,
  params: [AAaddress, nftImageUrl],
  value: 0,
});

// Wait for the result
const result = await waitForUserOpResult();
```

### 2. Token Creation Strategy

Similar to NFT minting, token creation is a state-changing operation requiring gas. Using UserOps allows for gas abstraction and a better user experience.

```javascript
await execute({
  function: 'createToken',
  contractAddress: TOKEN_FACTORY_ADDRESS,
  abi: CreateTokenFactory.abi,
  params: [tokenName, tokenSymbol, tokenSupply],
  value: 0,
});
```

### 3. NFT Gallery Strategy

For the NFT gallery, we use direct RPC calls because:

1. **No State Changes**: Just reading data, not modifying state
2. **No Gas Required**: Read operations are free
3. **Better Performance**: Direct calls are faster and simpler

```javascript
// Create a provider and contract
const provider = new ethers.providers.JsonRpcProvider(config.rpcUrl);
const nftContract = new ethers.Contract(FREE_NFT_ADDRESS, NERO_NFT_ABI, provider);

// Read the data directly
const balance = await nftContract.balanceOf(AAaddress);
const tokenURI = await nftContract.tokenURI(tokenId);
```

## Key Technical Challenges & Solutions

### 1. ABI Handling

We needed to ensure the correct ABI included the `mint` function for the NeroNFT contract:

```javascript
const NERO_NFT_ABI = [
  ...ERC721_ABI,  // Include standard ERC721 functions
  'function mint(address to, string memory uri) returns (uint256)',
  'function tokenURI(uint256 tokenId) view returns (string memory)',
];
```

### 2. Error Handling

We implemented robust error handling for both UserOps and direct RPC calls:

```javascript
try {
  // Attempt operation
} catch (error) {
  console.error('Error:', error);
  setTxStatus('An error occurred');
  // Fallback behavior for gallery
  setNfts([/* sample NFTs */]);
} finally {
  setIsLoading(false);
}
```

### 3. Optimistic UI Updates

For better UX, we update the UI optimistically after operations:

```javascript
if (result.result === true) {
  setTxStatus(`Success! NFT "${nftName}" minted!`);
  setIsPolling(false);
  // Reset form
  setNftName('');
  setNftDescription('');
  setNftImageUrl('');
  // Refresh NFT gallery
  fetchNFTs();
}
```

## Making the Most of NERO Wallet's Account Abstraction Features

### 1. Gas Sponsorship

The NERO Wallet configuration includes a paymaster that can sponsor gas fees:

```javascript
aa: {
  bundler: 'https://bundler.service.nerochain.io',
  paymaster: 'https://paymaster-testnet.nerochain.io',
  paymasterAPIKey: 'YOUR_API_KEY_HERE',
},
```

This allows users to perform transactions without holding NERO tokens.

### 2. Social Login

The Web3Auth integration enables social login without private keys:

```javascript
loginConfig: {
  google: {
    name: 'google',
    verifier: 'NeroTest-Google-Maintest',
    typeOfLogin: 'google',
    clientId: import.meta.env.VITE_GOOGLE_CLIENT_ID,
  },
  // ...other login methods
}
```

### 3. Transaction Batching

Though not implemented in our example, the NERO Wallet supports transaction batching, allowing multiple operations to be executed in a single transaction.

## Best Practices for NERO Wallet Development

1. **Use UserOps for Write Operations**: Any operation that changes state should use UserOps
2. **Use Direct RPC for Read Operations**: Reading data should bypass UserOps for efficiency
3. **Handle Errors Gracefully**: Provide fallbacks and clear error messages
4. **Optimize UI for Mobile**: Many users will access the wallet from mobile devices
5. **Secure User Data**: Don't store sensitive data in local storage
6. **Test on Multiple Networks**: Ensure your dApp works on both testnet and mainnet

## Further Expansion Possibilities

1. **Multi-send Feature**: Allow users to send tokens to multiple recipients in one transaction
2. **NFT Metadata Storage**: Store NFT metadata on IPFS for proper decentralization
3. **Batch Minting**: Allow users to mint multiple NFTs in a single operation
4. **Wallet Connect Integration**: Add support for connecting hardware wallets
5. **Transaction History**: Show users their past transactions
6. **Token Swapping**: Integrate DEX functionality for token swapping

## Conclusion

By understanding the concepts and implementation details behind the NERO Wallet, developers can build powerful dApps with account abstraction features. This approach significantly improves user experience by eliminating the need for users to manage private keys or hold tokens for gas fees, while maintaining the security and composability benefits of blockchain technology. 

<PageFeedback path="/en/tutorials/high-level/nero-wallet-architecture" />